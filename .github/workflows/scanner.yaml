name: Subdomain & Vulnerability Scanner (Enhanced & Robust)

on:
  workflow_dispatch:
    inputs:
      domain:
        description: 'Domain to scan'
        required: true
        default: 'example.com'
      severity:
        description: 'Nuclei severity filter (comma separated, e.g. critical,high,medium)'
        required: false
        default: 'critical,high,medium'
      port_scan:
        description: 'Enable port scanning (true/false)'
        required: false
        default: 'true'
      max_urls:
        description: 'Maximum URLs to scan with Nuclei'
        required: false
        default: '1000'
  schedule:
    - cron: '0 6 * * 1'  # Every Monday at 6 AM UTC

env:
  DOMAIN: ${{ github.event.inputs.domain || 'example.com' }}
  SEVERITY: ${{ github.event.inputs.severity || 'critical,high,medium' }}
  PORT_SCAN: ${{ github.event.inputs.port_scan || 'true' }}
  MAX_URLS: ${{ github.event.inputs.max_urls || '1000' }}

jobs:
  scan:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install system packages & tools
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y jq curl unzip git gcc make libpcap-dev

          # Install Go-based tools with error handling
          echo "Installing Go tools..."
          go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest || echo "subfinder install failed"
          go install -v github.com/projectdiscovery/nuclei/v3/cmd/nuclei@latest || echo "nuclei install failed"
          go install -v github.com/projectdiscovery/dnsx/cmd/dnsx@latest || echo "dnsx install failed"
          go install -v github.com/projectdiscovery/httpx/cmd/httpx@latest || echo "httpx install failed"
          go install -v github.com/projectdiscovery/naabu/v2/cmd/naabu@latest || echo "naabu install failed"
          go install -v github.com/tomnomnom/waybackurls@latest || echo "waybackurls install failed"
          go install -v github.com/lc/gau/v2/cmd/gau@latest || echo "gau install failed"
          go install -v github.com/projectdiscovery/katana/cmd/katana@latest || echo "katana install failed"

          echo "$HOME/go/bin" >> $GITHUB_PATH

      - name: Validate secrets
        run: |
          set -euxo pipefail
          if [ -z "${{ secrets.DISCORD_WEBHOOK }}" ]; then
            echo "::error::DISCORD_WEBHOOK secret is not set"
            exit 1
          fi
          echo "DISCORD_WEBHOOK=${{ secrets.DISCORD_WEBHOOK }}" >> $GITHUB_ENV

      - name: Create results directory
        run: |
          set -euxo pipefail
          mkdir -p results

      - name: Notify Start
        run: |
          set -euxo pipefail
          # Build JSON payload safely
          PAYLOAD=$(jq -n \
            --arg c "ðŸ” **Scan Started**" \
            --arg d "${{ env.DOMAIN }}" \
            --arg t "${{ github.event_name }}" \
            --arg tools "subfinder, dnsx, httpx, naabu, waybackurls, gau, katana, nuclei" \
            '{content: ($c + "\n**Domain:** " + $d + "\n**Trigger:** " + $t + "\n**Tools:** " + $tools)}')
          
          curl -s -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "${{ env.DISCORD_WEBHOOK }}" || echo "Failed to send start notification"

      - name: Discover subdomains
        run: |
          set -euxo pipefail
          echo "Starting subdomain discovery for ${{ env.DOMAIN }}"
          
          # Ensure output files exist
          touch results/subfinder.txt results/wayback_hosts.txt results/gau_hosts.txt results/katana_hosts.txt results/combined-subdomains.txt results/subdomains.txt
          
          subfinder -d "${{ env.DOMAIN }}" -all -silent -o results/subfinder.txt || echo "subfinder failed"
          echo "${{ env.DOMAIN }}" | waybackurls | sed -E 's#https?://([^/]+).*#\1#' | sort -u > results/wayback_hosts.txt || echo "waybackurls failed"
          gau "${{ env.DOMAIN }}" 2>/dev/null | sed -E 's#https?://([^/]+).*#\1#' | sort -u > results/gau_hosts.txt || echo "gau failed"
          echo "https://${{ env.DOMAIN }}" | katana -depth 2 -jc -silent | sed -E 's#https?://([^/]+).*#\1#' | sort -u > results/katana_hosts.txt || echo "katana failed"
          
          cat results/subfinder.txt results/wayback_hosts.txt results/gau_hosts.txt results/katana_hosts.txt | sort -u > results/combined-subdomains.txt
          
          cat > results/wordlist.txt <<'WL'
          www
          dev
          staging
          test
          api
          beta
          mail
          admin
          portal
          app
          m
          mobile
          cdn
          assets
          static
          images
          blog
          shop
          secure
          WL
          for p in $(cat results/wordlist.txt); do
            echo "${p}.${{ env.DOMAIN }}"
          done >> results/combined-subdomains.txt
          
          sort -u results/combined-subdomains.txt > results/subdomains.txt
          echo "SUBDOMAINS_FOUND=$(wc -l < results/subdomains.txt)" >> $GITHUB_ENV
          echo "Found $SUBDOMAINS_FOUND subdomains"

      - name: Resolve & probe alive hosts
        run: |
          set -euxo pipefail
          echo "Resolving subdomains and checking for alive hosts"
          
          touch results/resolved.txt results/resolved-hosts.txt results/alive.txt results/alive-urls.txt
          
          dnsx -l results/subdomains.txt -silent -a -r 1.1.1.1,8.8.8.8 -o results/resolved.txt || echo "dnsx failed"
          cut -d' ' -f1 results/resolved.txt | cut -d':' -f1 | sort -u > results/resolved-hosts.txt
          
          httpx -l results/resolved-hosts.txt -silent -follow-redirects -title -status-code -tech-detect -o results/alive.txt || echo "httpx failed"
          cut -d' ' -f1 results/alive.txt > results/alive-urls.txt
          
          echo "ALIVE_HOSTS=$(wc -l < results/resolved-hosts.txt)" >> $GITHUB_ENV
          echo "ALIVE_URLS=$(wc -l < results/alive-urls.txt)" >> $GITHUB_ENV
          echo "Found $ALIVE_HOSTS resolved hosts and $ALIVE_URLS alive URLs"

      - name: Port scan alive hosts (naabu)
        if: env.PORT_SCAN == 'true'
        run: |
          set -euxo pipefail
          touch results/naabu-ports.txt
          if [ -s results/resolved-hosts.txt ]; then
            echo "Starting port scan on alive hosts"
            naabu -list results/resolved-hosts.txt -silent -top-ports 1000 -o results/naabu-ports.txt || echo "naabu failed"
            echo "NAABU_LINES=$(wc -l < results/naabu-ports.txt)" >> $GITHUB_ENV
            echo "Found $NAABU_LINES open ports"
          else
            echo "NAABU_LINES=0" >> $GITHUB_ENV
            echo "No hosts to port scan"
          fi

      - name: Gather URLs & prepare for Nuclei
        run: |
          set -euxo pipefail
          echo "Gathering URLs for vulnerability scanning"
          
          touch results/wayback-urls.txt results/gau-urls.txt results/katana-urls.txt results/candidate-urls.txt results/nuclei-urls.txt
          
          waybackurls "${{ env.DOMAIN }}" > results/wayback-urls.txt || echo "waybackurls for URLs failed"
          gau "${{ env.DOMAIN }}" > results/gau-urls.txt || echo "gau for URLs failed"
          cat results/alive-urls.txt | katana -depth 2 -jc -silent -o results/katana-urls.txt || echo "katana for URLs failed"
          
          cat results/alive-urls.txt results/wayback-urls.txt results/gau-urls.txt results/katana-urls.txt | sort -u > results/candidate-urls.txt
          
          grep -viE "\.(jpg|jpeg|png|gif|svg|css|js|woff|woff2|ico|bmp|mp4|mp3|pdf|zip|tar|gz)$" results/candidate-urls.txt > results/nuclei-urls.txt
          
          if [ $(wc -l < results/nuclei-urls.txt) -gt ${{ env.MAX_URLS }} ]; then
            shuf -n ${{ env.MAX_URLS }} results/nuclei-urls.txt > results/nuclei-urls-limited.txt
            mv results/nuclei-urls-limited.txt results/nuclei-urls.txt
          fi
          
          echo "NUCLEI_URLS=$(wc -l < results/nuclei-urls.txt)" >> $GITHUB_ENV
          echo "Prepared $NUCLEI_URLS URLs for vulnerability scanning"

      - name: Update Nuclei templates
        run: |
          set -euxo pipefail
          nuclei -update-templates || echo "Nuclei template update failed"

      - name: Run Nuclei on URLs
        run: |
          set -euxo pipefail
          touch results/nuclei-urls-results.txt
          if [ -s results/nuclei-urls.txt ]; then
            echo "Running Nuclei on URLs"
            nuclei -l results/nuclei-urls.txt -severity "${{ env.SEVERITY }}" -o results/nuclei-urls-results.txt -silent || echo "Nuclei on URLs failed"
          fi

      - name: Run Nuclei on hosts
        run: |
          set -euxo pipefail
          touch results/nuclei-hosts-results.txt
          if [ -s results/resolved-hosts.txt ]; then
            echo "Running Nuclei on hosts"
            nuclei -l results/resolved-hosts.txt -severity "${{ env.SEVERITY }}" -o results/nuclei-hosts-results.txt -silent || echo "Nuclei on hosts failed"
          fi

      - name: Process Nuclei results
        run: |
          set -euxo pipefail
          touch results/nuclei-results.txt
          cat results/nuclei-urls-results.txt results/nuclei-hosts-results.txt | sed '/^$/d' | sort -u > results/nuclei-results.txt
          echo "VULNS_FOUND=$(wc -l < results/nuclei-results.txt || echo 0)" >> $GITHUB_ENV
          echo "Found $VULNS_FOUND vulnerabilities"
          
          if [ "${{ env.VULNS_FOUND }}" -gt 0 ]; then
            grep -oE '\[[^]]+\]' results/nuclei-results.txt | sort | uniq -c | sort -nr > results/vuln-summary.txt || echo "Failed to create vuln summary"
          else
            touch results/vuln-summary.txt
          fi

      - name: Notify Nuclei Summary
        run: |
          set -euxo pipefail
          if [ "${{ env.VULNS_FOUND }}" -gt 0 ]; then
            PAYLOAD=$(jq -n \
              --arg d "${{ env.DOMAIN }}" \
              --arg v "${{ env.VULNS_FOUND }}" \
              --arg s "${{ env.SEVERITY }}" \
              '{content: ("ðŸš¨ **Vulnerabilities Found!**\n**Domain:** " + $d + "\n**Severity Filter:** " + $s + "\n**Count:** " + $v)}')
          else
            PAYLOAD=$(jq -n \
              --arg d "${{ env.DOMAIN }}" \
              --arg s "${{ env.SEVERITY }}" \
              '{content: ("âœ… **Nuclei Complete**\n**Domain:** " + $d + "\n**Severity Filter:** " + $s + "\nNo vulnerabilities found.")}')
          fi
          curl -s -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "${{ env.DISCORD_WEBHOOK }}" || echo "Failed to send summary notification"

      - name: Send vulnerability summary
        if: env.VULNS_FOUND > 0
        run: |
          set -euxo pipefail
          if [ -s results/vuln-summary.txt ]; then
            SUMMARY=$(cat results/vuln-summary.txt | head -10 | awk '{print $2 " - " $1 " occurrences"}' | paste -sd '\n' -)
            PAYLOAD=$(jq -n \
              --arg d "${{ env.DOMAIN }}" \
              --arg s "$SUMMARY" \
              '{content: ("ðŸ“Š **Vulnerability Summary for " + $d + "**\n```\n" + $s + "\n```")}')
            curl -s -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "${{ env.DISCORD_WEBHOOK }}" || echo "Failed to send vuln summary"
          fi

      - name: Send individual vulnerabilities (max 20)
        if: env.VULNS_FOUND > 0
        run: |
          set -euxo pipefail
          MAX_MSG=20
          COUNT=0
          while IFS= read -r vuln; do
            [ "$COUNT" -ge "$MAX_MSG" ] && break
            URL=$(echo "$vuln" | grep -oE 'https?://[^[:space:]]+' | head -1 || echo "N/A")
            VULN_TYPE=$(echo "$vuln" | grep -oE '\[[^]]+\]' | head -1 || echo "N/A")
            SEVERITY=$(echo "$vuln" | grep -oE '\[.*\]' | tail -1 || echo "N/A")
            
            MSG="ðŸš¨ **Vulnerability Found**\n**Domain:** ${{ env.DOMAIN }}\n**URL:** $URL\n**Type:** $VULN_TYPE\n**Severity:** $SEVERITY\n\`\`\`\n$vuln\n\`\`\`"
            PAYLOAD=$(jq -n --arg msg "$MSG" '{content: $msg}')
            curl -s -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "${{ env.DISCORD_WEBHOOK }}" || echo "Failed to send individual vuln"
            COUNT=$((COUNT+1))
            sleep 1
          done < results/nuclei-results.txt

      - name: Create scan report
        run: |
          set -euxo pipefail
          cat > results/scan-report.md <<EOF
          # Scan Report for ${{ env.DOMAIN }}
          
          ## Scan Summary
          - **Domain:** ${{ env.DOMAIN }}
          - **Severity Filter:** ${{ env.SEVERITY }}
          - **Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          ## Results
          - **Subdomains Found:** ${{ env.SUBDOMAINS_FOUND }}
          - **Alive Hosts:** ${{ env.ALIVE_HOSTS }}
          - **Alive URLs:** ${{ env.ALIVE_URLS }}
          - **Open Ports:** ${{ env.NAABU_LINES }}
          - **URLs Scanned:** ${{ env.NUCLEI_URLS }}
          - **Vulnerabilities Found:** ${{ env.VULNS_FOUND }}
          
          ## Vulnerabilities
          EOF
          
          if [ "${{ env.VULNS_FOUND }}" -gt 0 ]; then
            cat results/nuclei-results.txt >> results/scan-report.md
          else
            echo "No vulnerabilities found." >> results/scan-report.md
          fi

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: scan-results-${{ env.DOMAIN }}-$(date +%Y%m%d-%H%M%S)
          path: results/
          retention-days: 30

      - name: Final notification
        run: |
          set -euxo pipefail
          PAYLOAD=$(jq -n \
            --arg d "${{ env.DOMAIN }}" \
            --arg s "${{ env.SEVERITY }}" \
            --arg sub "$(wc -l < results/subdomains.txt || echo 0)" \
            --arg alive "$(wc -l < results/alive-urls.txt || echo 0)" \
            --arg v "$(wc -l < results/nuclei-results.txt || echo 0)" \
            --arg ports "$(wc -l < results/naabu-ports.txt || echo 0)" \
            --arg urls "$(wc -l < results/nuclei-urls.txt || echo 0)" \
            '{content: ("âœ… **Scan Finished**\n**Domain:** " + $d + "\n**Severity:** " + $s + "\n**Subdomains:** " + $sub + "\n**Alive URLs:** " + $alive + "\n**Open Ports:** " + $ports + "\n**URLs Scanned:** " + $urls + "\n**Vulnerabilities:** " + $v)}')
          curl -s -X POST -H "Content-Type: application/json" -d "$PAYLOAD" "${{ env.DISCORD_WEBHOOK }}" || echo "Failed to send final notification"
